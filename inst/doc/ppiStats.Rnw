%
% NOTE -- ONLY EDIT THE .Rnw FILE!!!  The .tex file is
% likely to be overwritten.
%
% \VignetteIndexEntry{Using the package ppiStats}
%\VignetteDepends{}
%\VignettePackage{y2hStat}
\documentclass[11pt]{article}

\usepackage{times}
\usepackage{hyperref}

\usepackage[authoryear,round]{natbib}
\usepackage{times}
\usepackage{comment}

\textwidth=6.2in
\textheight=8.5in
%\parskip=.3cm
\oddsidemargin=.1in
\evensidemargin=.1in
\headheight=-.3in

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}

\bibliographystyle{plainnat}

\title{A Crash Course to using the R-Package ppiStats}
\author{T Chiang}

\begin{document}

\maketitle

For those interested in analyzing the publicly available protein-protein
interaction (PPI) data located within the IntAct repository, \Robject{ppiStats}
is an R-package that can parse through the IntAct repository and gather
empirical PPI data such as physical binary interactions between protein
pairs via the Yeast 2-Hybrid (Y2H) systems or such as complex co-membership between
sets of proteins via the Affinity Purification - Mass Spectrometry (AP-MS) 
systems. In this vignette, we show how one can collect such PPI data 
from IntAct, how one can take the collected data and generate useful R-objects
(such as the adjacency matrix representation, graph representations, etc), and 
how to do some simply statistical computations.

<<loadlib, echo=FALSE, results = hide>>=

library(ppiStats)

@

For the remainder of the vignette, we shall only be concerned with collecting 
three particular Y2H data-sets: those corresponding to "awasthi-2001-1", 
"cagney-2001-1", and "zhao-2005-2". 

The first function that we will call will be the \Rfunction{collectIntactPPIData}
function. As the name implies, this function goes into the Intact repository,
which exists within this package as a modified XML file downloaded from
its primary souce and collects the relevant data given the particular experiments 
(as given by its IntAct Accession (AC) Identification Code). In our working 
example ("awasthi-2001-1", "cagney-2001-1", "zhao-2005-2") is identified 
within IntAct by the AC codes ("EBI-531419", "EBI-698096","EBI-762635"). Before
we can gather the information concerning any empirical data, we must first 
identify its AC code.

<<collectData>>=

dataList <- collectIntactPPIData(c("EBI-531419", "EBI-698096","EBI-762635"))
names(dataList)
dataList[["shortLabel"]]

@ 

The return value for the function \Robject{collectIntactPPIData} is a list of
five elements. The "allBaits" and "allPreys" entries of this list contains the
IntAct Accession Identification Codes of all the unique proteins that proved to 
be viable baits (respectively viable preys) over all the experiments for which we
sought data (in our case, over all three experiments). 
The "baitsSystematic" and "preysSystematic" entries are named lists; the 
names corrospond to the IntAct AC codes while the entries are the systematic 
gene name(s) that each AC code can be mapped to.

<<exBaitsSys>>=
dataList[["baitsSystematic"]][1:5]
@

The "indexSetAll" entry of dataList contains the bait to prey associations
for each of the empirical data set. The "indexSetAll" entry contains sub-lists 
corresponding to each empirical data set. Each sub-list contains a number of 
length two character vectors: the first entry of this character vector is the
bait protein (give by AC code), and the second is the prey protein.

<<indexSet>>=
dataList[["indexSetAll"]][1]
@

As the structure of dataList stands, there is little we can do to manipulate 
the PPI data for mathematical, graphical, or statistical tests. Because of 
the undesirability of the data as is, we can generate a sparse matrix 
representation of the bait to prey affiliation data. For such a representation, 
we call the \Robject{createBPList} function using the entries "indexSetAll",
"baitsSystematic", and "preysSystematic" entries of the \Robject{dataList}
R-object as the arguments for \Robject{createBPList}.

<<createBPList>>=

bpList <- createBPList(dataList[["indexSetAll"]], dataList[["baitsSystematic"]], 
                        dataList[["preysSystematic"]])
names(bpList)
bpList[1]
@ 

The sparse matrix representation is given by a list of list. The top list contains
sub-lists which are named by each experimentor of the data-set (now called the
experimental sub-list). Each experimental sub-list itself contains a number of sub-lists 
(we shall refer to these sub-lists as bait sub-lists). Each bait sub-list is named by a
viable bait of the corresponding experiment. The entry for the bait sub-list is 
a character vector of proteins which were dectected by the corresponding bait. In 
essence, we can think of this sparse matrix representation as a rooted tree. The 
child of the root brings us to a particular experiment (data-set); the child of 
an experiment brings us to a viable bait of that experiment; and finally, the child of
a viable bait (the leaves of this rooted tree) is a viable prey of the viable bait.

How is this a sparse matrix representation? Well if we were to construct an adjacency
matrix for each experimental data-set where the viable baits of the experiment indexed the
rows and the viable preys of the experiment indexed the columns, we could put a 
non-negative integer for the number of times a viable bait detected a viable prey. This
matrix representation is generally sparse, and so to avoid carring all the zeros, our
R-object \Robject{bpList} suffices. 

It will be useful now to mention the two data files in the R-package \Rpackage{ppiStats}, 
\Robject{y2h} and \Robject{y2hSysGW} are of the same structure as \Robject{bpList}. Both 
\Robject{y2h} and \Robject{y2hSysGW} are collections of sparse matrix representations
for various empirical data-sets: \Robject{y2h} contains 42 Y2H experimental data-sets 
while \Robject{y2hSysGW} contains 7 Y2H data-sets under the condition that the prey 
population is genome-wide. Therefore \Robject{y2hSysGW} is a subset of \Robject{y2h}.

There will be times, however, when we would like to have the adjacency matrix representation 
of our data. When this is necessary, we can build these adjacency matrices by calling the
R-function \Rfunction{bpMatrix}.

<<>>=
bpMats <- lapply(bpList, function(x){
		bpMatrix(x, symMat = FALSE, homodimer = FALSE, baitAsPrey = FALSE,
    		unWeighted = TRUE, onlyRecip = FALSE, baitsOnly = FALSE)})

bpMats[1]	
@

Other than the sparse matrix representation for the empirical data, there are seven 
other arguments that the R-function \Rfunction{bpMatrix} takes. We shall discuss these
parameters in turn. The argument \Robject{homodimer} is a logical parameter; if FALSE,
all homodimer relationships will be disregarded, otherwise the homodimer relationships
will be recorded in the adjacency matrix. The argument \Robject{unWeighted} is also a 
logical; if TRUE, the entries of the adjacency matrix will be binary (0,1) to account
for the presence or absence of the bait to prey interaction without regards for 
multiplicity. Next, the argument \Robject{onlyRecip} is also a logical parameter; if
this argument is set to TRUE, the only interactions that the adjacency matrix will 
record will be those which are reciprocated, i.e. if protein b detects protein p and
if protein p detects protein b, these will be the only interactions recorded by the
the adjacency matrix, and so the matrix will be symmetric. The last three arguments,
\Robject{symMat}, \Robject{baitAsPrey}, and \Robject{baitsOnly} determines the indexing
set for the rows and columns of the adjacency matrix. If the \Robject{symMat} is TRUE,
the the union of viable baits and viable preys will index both the rows and columns;
this is necessary if we want to create an instance of the class \Rclass{graph}. If
the argument \Robject{baitAsPrey} is TRUE, then the columns are indexed by the 
union of viable baits and viable preys while the rows are indexed by only the viable
baits. Lastly, if the argument \Robject{baitsOnly} is TRUE, then the matrix will be
indexed by the viable baits in both the row and the columns of the adjacency matrix.
Based on the mathematical or statistical test or the graphical representation desired,
these parameters should be set accordingly.

Once we have generated the adjacency matrix, we can create an instance of the class
\Rclass{graph} by calling the \Rfunction{genBPGraph} function.  

<<>>=
bpMats1 <- lapply(bpList, function(x){
		bpMatrix(x, symMat = TRUE, homodimer = FALSE, baitAsPrey = FALSE,
    		unWeighted = TRUE, onlyRecip = FALSE, baitsOnly = FALSE)})
bpMats1[1]

bpGraphs <- lapply(bpMats1, function(x){genBPGraph(x, directed=TRUE, bp=FALSE)})
bpGraphs[1]
@ 

The \Rfunction{genBPGraph} is a simple function that takes three arguments. The first
is an adjacency matrix where the rows are indexed by baits and the columns are indexed
by the preys. The argument \Robject{directed} will create either a directed or an 
un-directed graph. And lastly, the argument \Robject{bp} is a logical; if TRUE, 
the adjacency matrix is that of a empirical bait to prey interaction matrix where
the bait population is not the same as the prey population. Hence, the function 
will extend the matrix to a larger matrix where the rows and columns are indexed by
the union of the baits and preys though the bait to prey interactions are 
preserved.

\end{document}
