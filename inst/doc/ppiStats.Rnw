%
% NOTE -- ONLY EDIT THE .Rnw FILE!!!  The .tex file is
% likely to be overwritten.
%
% \VignetteIndexEntry{Using the package ppiStats}
%\VignetteDepends{}
%\VignettePackage{y2hStat}
\documentclass[11pt]{article}

\usepackage{times}
\usepackage{hyperref}

\usepackage[authoryear,round]{natbib}
\usepackage{times}
\usepackage{comment}

\textwidth=6.2in
\textheight=8.5in
%\parskip=.3cm
\oddsidemargin=.1in
\evensidemargin=.1in
\headheight=-.3in

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}

\bibliographystyle{plainnat}

\title{A Crash Course to using the R-Package ppiStats}
\author{T Chiang}

\begin{document}

\maketitle

For those interested in analyzing the publicly available protein-protein
interaction (PPI) data located within the IntAct repository, \Robject{ppiStats}
is an R-package that can parse through the IntAct repository and gather
empirical PPI data such as physical binary interactions between protein
pairs via the Yeast 2-Hybrid (Y2H) systems or such as complex co-membership between
sets of proteins via the Affinity Purification - Mass Spectrometry (AP-MS) 
systems. In this vignette, we show how one can collect such PPI data 
from IntAct, how one can take the collected data and generate useful R-objects
(such as the adjacency matrix representation, graph representations, etc), and 
how to do some simply statistical computations.

<<loadlib, echo=FALSE, results = hide>>=

library(ppiStats)

@

For the remainder of the vignette, we shall only be concerned with collecting 
three particular Y2H data-sets: those corresponding to "awasthi-2001-1", 
"cagney-2001-1", and "zhao-2005-2". 

The first function that we will call will be the \Rfunction{collectIntactPPIData}
function. As the name implies, this function goes into the Intact repository,
which is exists within this package as a modified XML file, and collects 
the relevant data given a particular experiment (as given by its IntAct Accession
(AC) Identification Code).

<<collectData>>=

dataList <- collectIntactPPIData(c("EBI-531419", "EBI-698096","EBI-762635"))
names(dataList)
dataList[["shortLabel"]]

@ 

The return value for the function \Robject{collectIntactPPIData} is a list of
five elements. The "allBaits" and "allPreys" entries of this list contains the
IntAct Accession Identification Codes of all the unique proteins that proved to 
be viable baits (respectively viable preys) over all the experiments for which we
sought data (in our case, over all three experiments listed by the "shortLabel"
entry). The "baitsSystematic" and "preysSystematic" entries are named lists; the 
names corrospond to the IntAct AC codes while the entries are the systematic 
gene name(s) that each AC code can be mapped to.

<<exBaitsSys>>=
dataList[["baitsSystematic"]][1:5]
@

The "indexSetAll" entry of dataList contains the bait to prey associations
for each of the empirical data set. The "indexSetAll" entry contains sub-lists 
corresponding to each empirical data set. Each sub-list contains a number of 
length two character vectors: the first entry of this character vector is the
bait protein (give by AC code), and the second is the prey protein.

<<indexSet>>=
dataList[["indexSetAll"]][1]
@

As the structure of dataList stands, there is little we can do to manipulate 
the PPI data for mathematical, graphical, or statistical tests. Because of 
the undesirability of the data as is, we can generate a sparse matrix 
representation of the bait to prey affiliation data. For such a representation, 
we call the \Robject{createBPList} function using the entries "indedSetAll",
"baitsSystematic", and "preysSystematic" of dataList as the arguments.

<<createBPList>>=

bpList <- createBPList(dataList[["indexSetAll"]], dataList[["baitsSystematic"]], 
                        dataList[["preysSystematic"]])
names(bpList)
bpList[1]
@ 

The sparse matrix representation is given by a list of list. The top list contains
sub-lists which are named by each experimentor of the data-set (now called the
experimental sub-list). Each experimental sub-list itself contains a number of sub-lists 
(we shall refer to these sub-lists as bait sub-lists). Each bait sub-list is named by a
viable bait of the corresponding experiment. The entry for the bait sub-list is 
a character vector of proteins which were dectected by the corresponding bait. In 
essence, we can think of this sparse matrix representation as a rooted tree. The 
child of the root brings us to a particular experiment (data-set); the child of 
an experiment brings us to a viable bait of that experiment; and finally, the child of
a viable bait (the leaves of this rooted tree) is a viable prey of the viable bait.

How is this a sparse matrix representation? Well if we were to construct an adjacency
matrix for each experimental data-set where the viable baits of the experiment indexed the
rows and the viable preys of the experiment indexed the columns, we could put a 
non-negative integer for the number of times a viable bait detected a viable prey. This
matrix representation is generally sparse, and so to avoid carring all the zeros, our
R-object \Robject{bpList} suffices. 

It will be useful now to mention the two data files in the R-package \Rpackage{ppiStats}, 
\Robject{y2h} and \Robject{y2hSysGW} are of the same structure as \Robject{bpList}. 

There will be times, however, when we would like to have the adjacency matrix representation 
of our data. When this is necessary, we can build these adjacency matrices by calling the
R-function \Rfunction{bpMatrix}.

<<>>=
bpMats <- lapply(bpList, function(x){
		bpMatrix(x, symMat = FALSE, homodimer = FALSE, baitAsPrey = FALSE,
    		unWeighted = TRUE, onlyRecip = FALSE, baitsOnly = FALSE)})

bpMats[1]	
@




\end{document}
